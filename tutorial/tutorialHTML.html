<h1>Grails/React Offline App Tutorial</h1>
<h3>Introduction</h3>
<p>This tutorial is meant to be an introduction to React, specifically building react on top of a Grails backend. It assumes little to no React knowledge, and at least cursory knowledge of Grails.</p>
<p>We are going to be building a <a href="https://developers.google.com/web/progressive-web-apps/">progressive web app</a> that works even with no internet connection. It will be a simple fishing companion app that you would take on a fishing trip to document your catches.</p>
<p>We will be covering the following:</p>
<ul>
<li>Building a grails app</li>
<li><a href="https://grails-plugins.github.io/grails-spring-security-core/snapshot/index.html">Spring Security</a></li>
<li>React components</li>
<li>Using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">fetch</a> to talk to the app’s backend</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises</a></li>
<li><a href="https://developers.google.com/web/fundamentals/primers/service-workers/">ServiceWorkers</a> and <a href="https://github.com/localForage/localForage">Localforage</a></li>
<li><a href="https://jestjs.io/docs/en/getting-started">Jest</a> and <a href="airbnb.io/enzyme/">Enzyme</a></li>
</ul>
<h1>Grails/React Offline App Tutorial</h1>
<h3>Introduction</h3>
<p>This tutorial is meant to be an introduction to React, specifically building react on top of a Grails backend. It assumes little to no React knowledge, and at least cursory knowledge of Grails.</p>
<p>We are going to be building a <a href="https://developers.google.com/web/progressive-web-apps/">progressive web app</a> that works even with no internet connection. It will be a simple fishing companion app that you would take on a fishing trip to document your catches.</p>
<p>We will be covering the following:</p>
<ul>
<li>Building a grails app</li>
<li><a href="https://grails-plugins.github.io/grails-spring-security-core/snapshot/index.html">Spring Security</a></li>
<li>React components</li>
<li>Using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">fetch</a> to talk to the app’s backend</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises</a></li>
<li><a href="https://developers.google.com/web/fundamentals/primers/service-workers/">ServiceWorkers</a> and <a href="https://github.com/localForage/localForage">Localforage</a></li>
<li><a href="https://jestjs.io/docs/en/getting-started">Jest</a> and <a href="airbnb.io/enzyme/">Enzyme</a></li>
</ul>
<h3>Prerequisites</h3>
<p>The first thing we are going to do is set up our development environment. Before we start, install Yarn and Node using your machine’s preferred package manager. Also, if you’re using Chrome, install React Developer Tools <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi">here</a>. This is an extension allowing you to view your React application and all of its states and props, which helps with debugging.</p>
<p>In IntelliJ, set up a new Grails project. Under options, add the flag “—profile=react-webpack”
You can learn more about Grails profiles <a href="grails.org/profiles.html">here</a>. For our purposes, we are building a single React app that uses Grails as a backend</p>
<center><img src="images/1.png" alt="" height="500" width="700"></center> 
<p>After everything is initialized, go to <strong>build.gradle</strong> and find the ‘node’ option. Update the values for version and yarnVersion to reflect the current versions of yarn and node respectively. At the time of writing, they are v10.2.1 and 1.7.0, but you can run <code>node -v</code> and <code>yarn -v</code> to check them.</p>
<p>The first run will take the longest to initialize everything, so let’s get this out of the way now, as well as make sure everything is in working order. We should be greeted with this page:</p>
<center><img src="images/2.png" alt="" height="400" width="600"></center>
<p>Next, we need to download some node modules that our app will depend on. In the terminal in Intellij, run the command <code>yarn add -D localforage jest enzyme enzyme-adapter-react-16</code>.
The -D flag stands for ‘dev’, as these are developer dependencies. Refer back to list of things covered for more information on these packages. Enzyme is a testing utility for React, and the adapter is used to run Jest tests through it. The number at the end of the package (16) must correspond to the version of React you are using, which can be found in the <strong>package.json</strong> file under dependencies. This file is information about the app, as well as all the node modules it requires.</p>
<h3>Backend</h3>
<p>The basic idea of this app is that the user catches a fish in real life. The fisher then opens the app and fills out a form detailing the catch they just landed. This form data gets saved into Grails as a ‘Catch’ that can then be looked up. The backend is going to be where we house our database and user authentication.</p>
<p>First, we are going to add Spring Security Core. This allows for us to authenticate users. Add this line to <strong>build.gradle</strong> at the end of the dependencies list after line 69.</p>
<pre><code class="language-groovy">dependencies {
    compile "org.springframework.boot:spring-boot-starter-logging"
    compile "org.springframework.boot:spring-boot-autoconfigure"
    compile "org.grails:grails-core"
    compile "org.springframework.boot:spring-boot-starter-actuator"
    compile "org.springframework.boot:spring-boot-starter-tomcat"
    compile "org.grails:grails-web-boot"
    compile "org.grails:grails-logging"
    compile "org.grails:grails-plugin-rest"
    compile "org.grails:grails-plugin-databinding"
    compile "org.grails:grails-plugin-i18n"
    compile "org.grails:grails-plugin-services"
    compile "org.grails:grails-plugin-url-mappings"
    compile "org.grails:grails-plugin-interceptors"
    compile "org.grails.plugins:cache"
    compile "org.grails.plugins:async"
    compile "org.grails.plugins:scaffolding"
    compile "org.grails:grails-plugin-gsp"
    compile "org.grails.plugins:events"
    compile "org.grails.plugins:hibernate5"
    compile "org.hibernate:hibernate-core:5.1.5.Final"
    compile "org.grails.plugins:gsp"
    compile "org.grails.plugins:views-json"
    compile "org.grails.plugins:views-json-templates"
    console "org.grails:grails-console"
    profile "org.grails.profiles:react-webpack"
    runtime "org.glassfish.web:el-impl:2.1.2-b03"
    runtime "com.h2database:h2"
    runtime "org.apache.tomcat:tomcat-jdbc"
    runtime "com.bertramlabs.plugins:asset-pipeline-grails:2.14.8"
    testCompile "org.grails:grails-gorm-testing-support"
    testCompile "org.grails:grails-web-testing-support"
    testCompile "org.grails.plugins:geb:1.1.2"
    testRuntime "org.seleniumhq.selenium:selenium-chrome-driver:2.47.1"
    testRuntime "org.seleniumhq.selenium:selenium-htmlunit-driver:2.47.1"
    testRuntime "net.sourceforge.htmlunit:htmlunit:2.18"
    // Adds Spring Security plugin
    compile 'org.grails.plugins:spring-security-core:3.2.0'
}
</code></pre>
<p>Next, open up the Grails command window under <strong>Tools &gt; Grails &gt; Run Grails Command</strong>.
Run this command to set up Users and User Roles, making sure to replace ‘fishing_app’ with whatever you named your project. This guide will be referring to it as ‘fishing_app’.</p>
<center><img src="images/3.png" alt="" height="200" width="600"></center>
<p>Open up <em>/grails-app/conf/application.groovy</em>. At the bottom of the staticRules array, add these rules starting at line 18:</p>
<pre><code class="language-groovy">[pattern: '/logout/**',      access: ['permitAll']],  // for easy access to logout
[pattern: '/catch/**',       access: ['ROLE_USER']],  // for catch controller
[pattern: '/sw.js',          access: ['permitAll']],  // for service worker
[pattern: '/User/getLogin',  access: ['permitAll']],  // to check user login info
[pattern: '/dbconsole/**',   access: ['ROLE_ADMIN']], // for access to H2 console
</code></pre>
<p>These define what user roles can access what urls. Right now, they don’t exist, but they will in a minute. At the very bottom of the file, after the chainMap array, add the line:</p>
<pre><code class="language-groovy">grails.plugin.springsecurity.logout.postOnly = false
</code></pre>
<p>This gives the user an easier time logging out by not requiring a POST request.</p>
<p>Next, go to <em>/grails-app/conf/application.yml</em>. In this file, we will be specifying some rules regarding uploading files. At the very top, add this resources line to the end of the block starting at line 11.</p>
<pre><code class="language-yml">resources:
    pattern: '/**'
</code></pre>
<p>This allows us to access external files as we need them. In the second grails: block, under controllers, add this block below the <code>defaultScope: singleton</code> declaration:</p>
<pre><code class="language-yml">    upload:
        maxFileSize: 262144000
        maxRequestSize: 262144000
</code></pre>
<p>This allows us to upload normal sized images to Grails.</p>
<p>Now, back to the User domain we just created. In <em>/grails-app/domain/fishing_app/User</em> we are going to add a couple fields to personalize the User. Add a first and last name to the list of properties.</p>
<pre><code class="language-groovy">String username
String password
String fname 
String lname 
boolean enabled = true
boolean accountExpired
boolean accountLocked
boolean passwordExpired
</code></pre>
<p>We are going to create a new domain now to represent the ‘Catch’ that was mentioned earlier. Create a new Grails Domain Class by right clicking the domain folder and selecting <strong>New &gt;</strong>. Call it Catch. Fill it out like this:</p>
<pre><code class="language-groovy">package fishing_app

class Catch {
    String tripName
    String fishType
    String comment
    Float xCoord
    Float yCoord
    Date dateCaught
    String image

    static belongsTo = [user: User]

    static constraints = {
        tripName blank: false
        fishType blank: false
        comment nullable: true
        xCoord nullable: true
        yCoord nullable: true
        dateCaught blank: false
        image nullable: true
    }
}
</code></pre>
<p>These fields are what the user is going to fill out in the form. Note that the constraints say that the tripName, fishType, and dateCaught cannot be blank. The other fields are optional.</p>
<p>These domains need controllers. The controllers are where we house the logic for the backend. The same way we made a new domain we can make new controllers. Make one for both Catch and User.</p>
<p>The User controller is simple. It will contain one function that checks whether or not we are logged in.</p>
<pre><code class="language-groovy">package fishing_app

class UserController {
    def springSecurityService

    def index() { }

    // this function checks if the user is logged in
    def getLogin() {
        User user = springSecurityService.currentUser

        if (user != null) {
            render user.fname
        }
        else {
            render false
        }
    }
}
</code></pre>
<p>The Catch controller has a couple of functions. The first function looks up all Catches made by the currently logged in User.</p>
<pre><code class="language-groovy">import grails.converters.JSON

class CatchController {
    def springSecurityService

    def index() { }

    def getCatches() {
        User user = springSecurityService.currentUser
        render Catch.findAllByUser(user).toArray() as JSON
    }
}
</code></pre>
<p>Pay special attention to the name of the function. Remember this line that was added to <strong>application.groovy</strong>?</p>
<pre><code class="language-groovy">[pattern: '/catch/**',       access: ['ROLE_USER']],  // for catch controller
</code></pre>
<p>The access key means that only users with the role <strong>ROLE_USER</strong> can access the catch controller, i.e. we have to be logged in. Similarly, the line</p>
<pre><code class="language-groovy">[pattern: '/User/getLogin',   access: ['permitAll']],  // to check user login info
</code></pre>
<p>Refers to the getLogin function in the User controller. This line means anybody can call this function, logged in or not.</p>
<p>In the Catch controller, add another function called newCatch. It will contain the logic for converting the form data into a Catch object to save to Grails. It will look like this:</p>
<pre><code class="language-groovy">// Takes form parameters and saves it to the database
def newCatch() {
    User user = springSecurityService.currentUser   // get current user

    def tripName = params.tripName
    def fishType = params.fishType
    def dateCaught = params.dateCaught
    def xCoord = params.xCoord
    def yCoord = params.yCoord
    def comment = params.comment
    def image = params.image

    def dateCaughtModified = new Date().parse("yyyy-MM-dd", dateCaught)

    def destFilename
    def imageUpload = image
    def img_path = "/Desktop/directed_study/code/building/grails/fishing_app/src/main/webapp/images/uploaded"

    // if image was passed else make it null (queue sends null parameter as string)
    if (imageUpload != null &amp;&amp; imageUpload != "null") {
        def destDir = System.getProperty("user.home") + img_path

        def id = UUID.randomUUID().toString()
        while (Catch.countByImage(id) &gt; 0) {  // if this photo name already exist make a new one
            id = UUID.randomUUID().toString()
        }


        destFilename = String.format("%s.jpg", id)
        File destFile = new File(destDir, destFilename)

        destFile.createNewFile()
        imageUpload.transferTo(destFile)

    }
    else {
        destFilename = null
    }

    def fishCatch = new Catch(
            user: user,
            tripName: tripName,
            fishType: fishType,
            dateCaught: dateCaughtModified,
            xCoord: xCoord,
            yCoord: yCoord,
            comment: comment,
            image: destFilename,
    )

    fishCatch.save(flush: true, failOnError: true)
    render "Success!"
}
</code></pre>
<p><strong>NOTE: MAKE SURE YOU UPDATE img_path TO REFLECT WHERE YOUR PROJECT IS LOCATED.</strong></p>
<p>Make a new directory in <em>/src/main/webapp/images/</em> called ‘uploaded’. This will be where all our uploaded images get stored. To be sure img_path is correct, just copy the absolute path of the newly created directory &amp; use that as the value.</p>
<p>Finally, we will create some test data to make sure everything is in working order. In
<em>/grails-app/init/fishing_app/BootStrap</em> add the following. The values can be replaced however you want, and additional catches can be added.</p>
<pre><code class="language-groovy">class BootStrap {

    def init = { servletContext -&gt;

        def today = new Date()

        // Add for creating Roles and Users
        // def adminRole = new Role(authority: 'ROLE_ADMIN').save(flush: true)
        def userRole = new Role(authority: 'ROLE_USER').save(flush: true)

        // Create the account and save it
        def testUser = new User(username: 'b', password: 'password', fname: 'Bryce', lname: 'Williams')

        testUser.save(flush: true)

        UserRole.create testUser, userRole, true
        UserRole.withSession {
            it.flush()
            it.clear()
        }

        // Create a fish and save it
        def fish = new Catch(
                tripName: "Up State",
                fishType: "Walleye",
                comment: "It was cold",
                dateCaught: today,
                xCoord: 47.1211,
                yCoord: 88.5694,
                image: "later.png",
                user: testUser
        )

        fish.save(flush:true)

    }


    def destroy = {
    }
}
</code></pre>
<p>A couple things to point out:</p>
<ul>
<li>adminRole is used for administrative purposes. You can give special permissions to different roles.</li>
<li>The value for the image in the catch is just a placeholder. It does not actually refer to anything.</li>
</ul>
<p>Now, when we re-run the app, we are greeted with the same startup page. However, controller functions can be referenced as URLs. For example, let’s test the getLogin() function in the User controller. In the browser, add <em>/user/getLogin</em> to the end of the url. We should be greeted with this page:</p>
<center><img src="images/4.png" alt="" height="200" width="600"></center>
<p>It renders false, because we aren’t logged in. Try navigating to the <code>getCatches()</code> function in the catch controller. It’s secured, so we shouldn’t be able to, right? <em>/catch/getCatches</em> will redirect us to the log in page, thanks to Spring Security.</p>
<center><img src="images/5.png" alt="" height="400" width="500"></center>
<p>Log in with the bootstrapped account, and we will be redirected to the correct page</p>
<center><img src="images/6.png" alt="" height="100" width="600"></center>
<p>Now, go back to the <em>/user/getLogin</em> page. It should now show us who we’re logged in as.</p>
<center><img src="images/7.png" alt="" height="200" width="600"></center>
<p>That’s it for the backend. Now we have a foundation for the frontend which we will be building in React.</p>
<h3>Frontend</h3>
<p>Recall the fishing scenario from earlier. The frontend is going to contain the form and all of the rest of the user interactions.</p>
<p>Open <em>/src/main/webapp/App.js</em>. This is where we are going to build the frontend. If you study the code in the <code>render() { }</code> block, you’ll notice that this is what is being displayed when we run the app. It may look daunting at first, but React is simpler than it seems.</p>
<p>First, we are going to replace the Navbar with our own. We will start by replacing the App.js file with the below:</p>
<pre><code class="language-js">import React, { Component } from <span class="hljs-string">'react'</span>;
import { Button } from <span class="hljs-string">'react-bootstrap'</span>;

<span class="hljs-comment">/** components */</span>
import AppNav from <span class="hljs-string">'./AppNav'</span>

import <span class="hljs-string">'whatwg-fetch'</span>;


<span class="hljs-keyword">class</span> App extends Component {
    constructor() {
        super();

        <span class="hljs-keyword">this</span>.state = {
            online: <span class="hljs-literal">true</span>,
            logged_in: <span class="hljs-literal">false</span>,
        }
    }

    render() {
        <span class="hljs-keyword">const</span> {
            online,
            logged_in,
        } = <span class="hljs-keyword">this</span>.state

        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">AppNav</span>
                    <span class="hljs-attribute">logged_in</span>=<span class="hljs-value">{logged_in}</span>
                    <span class="hljs-attribute">online</span>=<span class="hljs-value">{online}</span>
                /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        );
    }
}

export default App;
</span></code></pre>
<p>App.js is what is known as a <a href="https://reactjs.org/docs/react-component.html">React Component</a>. Look at the reference for more details. The basic idea is that components can be defined as classes or functions. Components defined as classes have the constructor block and usually defines a <a href="https://reactjs.org/docs/state-and-lifecycle.html">state</a>. The state of a component can be thought of as a list of global variables that are immutable. If the app changes state, it must re-render to reflect those changes.
The block starting at line 10 is the constructor. The call to <code>super()</code> initializes the constructor so that the component can use the <code>this</code> keyword. The next line defines the state of the app. It defines two booleans: <code>online</code> and <code>logged_in</code>. <code>online</code> is going to indicate whether or not the user is online, and <code>logged_in</code>, whether or not the user is logged in.
Every component must have a <code>render() { }</code> block. The html-esque tags in the return statement are converted to html and get displayed in the browser. Before the return statement, additional logic that controls what gets rendered can be placed here. Lines 22-25 is a shorthand way of referencing state variables. Without this, online and logged_in must be referenced using <code>this.state.online</code> and <code>this.state.logged_in</code>. Finally, the tag at line 29 is our Navbar. Lines 30 and 31 are called props. These are parameter variables passed to a component in the same way a function is called with arguments. We will touch on this more in a second.</p>
<p>Navigate to AppNav.js. Replace the contents with the following:</p>
<pre><code class="language-js">import React from <span class="hljs-string">'react'</span>;
import { Navbar, Nav, NavItem } from <span class="hljs-string">'react-bootstrap'</span>;

import { nav_styles } from <span class="hljs-string">'./util/Styles'</span>

import <span class="hljs-string">'whatwg-fetch'</span>;

<span class="hljs-keyword">const</span> AppNav = props =&gt; {
    <span class="hljs-keyword">const</span> {
        logged_in,
        online
    } = props;


    <span class="hljs-comment">// conditionally renders login/logout link</span>
    <span class="hljs-keyword">const</span> nav = (link) =&gt; {
        <span class="hljs-keyword">return</span> (
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Navbar</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{nav_styles.nav}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">Nav</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{nav_styles.item}</span> <span class="hljs-attribute">pullLeft</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">NavItem</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">{'</span>/'}&gt;</span>
                        The Fishing App
                    <span class="hljs-tag">&lt;/<span class="hljs-title">NavItem</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">Nav</span>&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-title">Nav</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{nav_styles.item_right}</span> <span class="hljs-attribute">pullRight</span>&gt;</span>
                    { /* only show login/logout button if online */
                        online &amp;&amp;
                        link
                    }
                <span class="hljs-tag">&lt;/<span class="hljs-title">Nav</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">Navbar</span>&gt;</span>
        )
    }


    const login = <span class="hljs-tag">&lt;<span class="hljs-title">NavItem</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">{'</span>/<span class="hljs-attribute">login</span>/<span class="hljs-attribute">auth</span>'}&gt;</span>Log In<span class="hljs-tag">&lt;/<span class="hljs-title">NavItem</span>&gt;</span>;</span>
    <span class="hljs-keyword">const</span> logout = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">NavItem</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">{'</span>/<span class="hljs-attribute">logout</span>'}&gt;</span>Log Out<span class="hljs-tag">&lt;/<span class="hljs-title">NavItem</span>&gt;</span>;</span>

    <span class="hljs-keyword">if</span> (logged_in)
        <span class="hljs-keyword">return</span> nav(logout)
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> nav(login)
}


export <span class="hljs-keyword">default</span> AppNav;
</code></pre>
<p>AppNav is a component that is defined as a function rather than a class. These are also known as <a href="https://hackernoon.com/react-stateless-functional-components-nine-wins-you-might-have-overlooked-997b0d933dbc">stateless</a> functional or dumb components. They do not have as much overhead as a stateful component, and are meant to inherit state from their parent as properties.</p>
<p>Before we do anything, there is some styling we need to add. The import at line 4 will be throwing an error, because that file does not exist yet. In the <em>/src/</em> folder, make a directory called <em>util</em>. This is where we will be keeping extra JavaScript files that are not components. Make a JavaScript file called Styles, and fill it out like below. Then, navigate to <em>/src/main/webapp/css/App.css</em> and comment everything out.</p>
<pre><code class="language-js"><span class="hljs-comment">/** APP */</span>
<span class="hljs-keyword">const</span> button = {
    margin: <span class="hljs-string">"5px"</span>,
    display: <span class="hljs-string">"flex"</span>,
    justifyContent: <span class="hljs-string">"center"</span>
}

<span class="hljs-keyword">const</span> app_styles = {
    button: button
}


<span class="hljs-comment">/** NAVBAR */</span>
<span class="hljs-keyword">const</span> nav = {
    backgroundColor: <span class="hljs-string">"#73b566"</span>,
    backgroundImage: <span class="hljs-string">"none"</span>,
    marginBottom: <span class="hljs-string">"15px"</span>
}

<span class="hljs-keyword">const</span> item = {
    display: <span class="hljs-string">"inline-block"</span>
}

<span class="hljs-keyword">const</span> item_right = {
    display: <span class="hljs-string">"inline-block"</span>,
    float: <span class="hljs-string">"right"</span>
}


<span class="hljs-keyword">const</span> nav_styles = {
    nav: nav,
    item: item,
    item_right: item_right
}

export { app_styles, nav_styles }
</code></pre>
<p>In React, styles are declared like objects. The css properties names are the same, except that the ones that are words separated by a dash become camelCase. One way to add styling is to make them like this, but they can also be added inline as well. Check <a href="https://codeburst.io/4-four-ways-to-style-react-components-ac6f323da822">this</a> article out to see more ways to style your components.</p>
<p>Now, back to AppNav. The first thing you may notice is the strange declaration of the function at line 8. This is called an <a href="https://codeburst.io/javascript-arrow-functions-for-beginners-926947fc0cdc">arrow-function</a>. The key differences between a regularly declared function and an arrow function are that arrow functions are written in a cleaner syntax, and they do not bind the keyword <code>this</code>. What that means is that any arrow function that references <code>this</code> references the original binding, and doesn’t try to look for something inside the function. This will be expanded on more as we go through the guide. Check the arrow-function link for a more in-depth explanation.</p>
<p>Lines 9-12 are a cleaner way to declare the props that are being passed to the component. They can be listed as separate parameters like so:
<code>const AppNav = ({logged_in, online}) =&gt; {…}</code>
and would change nothing about the functionality.</p>
<p>Line 16-33 is the navbar itself. It is being built as a function because it contains the login/logout button. Which button gets displayed depends on the <code>logged_in</code> prop. This is called <a href="https://reactjs.org/docs/conditional-rendering.html">conditional rendering</a>. The link that gets passed as a parameter is going to be one of the NavItems declared on lines 36 and 37. Furthermore, we only want to display this link if the app is online, since logging in or out requires an internet connection. The block at line 26-29 is how we achieve this. It is similar to the logical <code>and</code> in other programming languages, the idea being that if the first half is true, then it will look at the second half, and skip over it otherwise.</p>
<p>Finally, the line at the very bottom tells React to export the function so that it can be imported in another file.</p>
<p>Now, re-run the app. Our app should now look like this:</p>
<center><img src="images/8.png" alt="" height="300" width="600"></center>
<p>Now, try logging in. It works as expected, but now we can’t log out. This is because we never update the <code>logged_in</code> state. Back in App.js add this underneath the constructor:</p>
<pre><code class="language-js"> <span class="hljs-comment">/** checks for online &amp; logged in status */</span>
componentWillMount() {
    <span class="hljs-comment">// check if online</span>
    <span class="hljs-keyword">this</span>.setState({online: navigator.onLine})

    <span class="hljs-comment">// check if logged in</span>
    <span class="hljs-keyword">const</span> url = <span class="hljs-string">"/user/getLogin"</span>;

    fetch(url, {
        method: <span class="hljs-string">'GET'</span>,
        credentials: <span class="hljs-string">'same-origin'</span>,
    })
    .then(r =&gt; r.text())
    .then(text =&gt; {
        <span class="hljs-keyword">if</span> (text === <span class="hljs-string">'false'</span>){
            <span class="hljs-keyword">this</span>.setState({logged_in: <span class="hljs-literal">false</span>})
        }

        <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">this</span>.setState({logged_in: <span class="hljs-literal">true</span>})
        }
    })
}
</code></pre>
<p><code>componentWillMount</code> is what’s called a <a href="https://reactjs.org/docs/react-component.html">lifecycle function</a>. They are used to update a component during a specific phase of its lifecycle. In this case, we want to check the app’s logged in status as it’s mounting so that it will be ready upon first use.</p>
<p>The very first thing it does is checks if the app is online. navigator.onLine is a JavaScript property that lets us know if there is a connection or not, so we will set our online state to reflect it. Then, if we are online, we can <code>fetch</code> the logged in status from Grails. <a href="https://developers.google.com/web/updates/2015/03/introduction-to-fetch">Fetch</a> is similar to ajax, but it is built on <a href="https://developers.google.com/web/fundamentals/primers/promises">Promises</a>, which is a more simplified way of doing asynchronous tasks than callbacks. We will expound upon how to build our own Promises later. Building the request is simple: the call is <code>fetch(url, {options})</code>. The url is the same as what we manually navigated to earlier. The options we specify will be <code>method</code> and <code>credentials</code> Our method is <code>‘GET’</code> because we are retrieving information, and we set the credentials to <code>‘same-origin’</code>.
A promise is a function that does an operation, and returns one of two functions depending on the results. If the operation succeeds, it will <code>resolve()</code>, otherwise it will <code>reject()</code>. These correspond to <code>.then()</code> and <code>.catch()</code> respectively. In our example, when fetch is called, it’s really calling the <code>getLogin</code> function in the user controller, and passing the result to <code>resolve()</code>. On line 33, <code>.then()</code> is how we retrieve the response which is what the variable <code>r</code> is. All responses from fetch come back as objects, but they can be transformed if need be. For this use, we just want the text, so we will be calling the <code>text()</code> function on the response. This returns another Promise, so we will need to use <code>.then()</code> one more time to get the text. This is called chaining promises, which can be done as many times as necessary. Doing the same thing with callbacks is possible, but infinitely more messy and harder to follow. Inside this promise resolution, we can set the <code>logged_in</code> state to reflect what Grails sees.</p>
<p>Re-run the app, and now the login button updates like it’s supposed to!</p>
<p>One last thing before we move on: Due to the nature of the app’s usage, we cannot assume the user’s internet connection will be stable. If the app thinks the user is online after they have lost connection, problems could arise. We want the app to check its online status whenever possible. Under the <code>componentWillMount()</code> function add this lifecycle function:</p>
<pre><code class="language-js"> <span class="hljs-comment">/** updates the online status */</span>
componentWillUpdate() {
    <span class="hljs-comment">// if online status was changed</span>
    <span class="hljs-keyword">const</span> { online } = <span class="hljs-keyword">this</span>.state

    <span class="hljs-keyword">if</span> (online !== navigator.onLine)
        <span class="hljs-keyword">this</span>.setState({online: navigator.onLine})
}
</code></pre>
<p>This function gets called every time the component updates, like during a state change or a rendering of another component. It simply checks the online property against its own online state, and sets the state to match the property if it changed.</p>
<p>Next, we are going to add a feature to display the catches we landed, i.e. getCatches. Functionally, it will work like this: if the user is online and logged in a request can be made to Grails from React to retrieve the catches. This means we will need to keep track of the catches somehow. We would also like to be able to view the details of each catch. The workflow then is to make a fetch request to Grails, and store the catches in a table to be viewed. We will start by adding a couple more things to the state. In the constructor, add these to the state:</p>
<pre><code class="language-js">posted_catches: [],             <span class="hljs-comment">// catches in the database</span>

showing_detail_modal: <span class="hljs-literal">false</span>,    <span class="hljs-comment">// catch detail modal</span>
display_catch: {},              <span class="hljs-comment">// catch info to display</span>

showing_loading_modal: <span class="hljs-literal">false</span>,   <span class="hljs-comment">// modal indicating something is loading</span>
loading_message: <span class="hljs-string">''</span>,            <span class="hljs-comment">// message to display on the modal</span>
</code></pre>
<p>The states are as follows:</p>
<ul>
<li><code>posted_catches</code> - an array of catches retrieved from Grails</li>
<li><code>showing_detail_modal</code> - a boolean that indicates whether or not the detail modal is being displayed. The detail modal is going to be a modal that displays the information of the catch that has been selected.</li>
<li><code>display_catch</code> - the catch that will be displayed in the above modal.</li>
<li><code>showing_loading_modal</code> - a boolean indicating whether or not the loading modal is being displayed. The loading modal will be a simple modal that shows when an asynchronous task like a fetch is being done. Its purpose is to let the user know that the app is actually doing work and silently failing. The modal disappears automatically when the task is done.</li>
<li><code>loading_message</code> - the message to be displayed on the loading modal. This message will tell the user which async task is being performed.</li>
</ul>
<p>Being that we will be working with arrays quite a bit, it would be useful to have a helper function to check whether or not an array is empty. In the <em>util</em> folder, make a JavaScript file called <code>ArrayFunc</code>. You can go ahead and put functions in here that will make your array operations easier, but the main function we will be using in this app is this one:</p>
<pre><code class="language-js">export <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(array)</span> </span>{
    <span class="hljs-keyword">return</span> (array === <span class="hljs-literal">undefined</span> || array === <span class="hljs-literal">null</span> || array.length === <span class="hljs-number">0</span>)
}
</code></pre>
<p>Update the imports in App.js to include this, as well as the following:</p>
<pre><code class="language-js">import React, { Component } from <span class="hljs-string">'react'</span>;
import { Button } from <span class="hljs-string">'react-bootstrap'</span>;

<span class="hljs-comment">/** components */</span>
import AppNav from <span class="hljs-string">'./AppNav'</span>

import CatchTable from <span class="hljs-string">'./components/CatchTable'</span>
import CatchDetailModal from <span class="hljs-string">'./components/modals/CatchDetailModal'</span>
import LoadingModal from <span class="hljs-string">'./components/modals/LoadingModal'</span>

<span class="hljs-comment">/** helper stuff */</span>
import isEmpty from <span class="hljs-string">'./util/ArrayFunc'</span>

<span class="hljs-comment">/** styling */</span>
import { app_styles } from <span class="hljs-string">'./util/Styles'</span>

import <span class="hljs-string">'whatwg-fetch'</span>;
</code></pre>
<p>Lines 7-9 are going to be the components we need next. In <em>/src/webapp/</em> make a directory called components. This will house all our additional components. Inside the <em>/components/</em> directory, make another directory called <em>modals</em>. We will be keeping our various modals here. Before we continue building out the app, let’s make these components.</p>
<p>The catch table will be where all of our catches get displayed. In components, make a JavaScript file called <code>CatchTable</code>.</p>
<pre><code class="language-js">import React from <span class="hljs-string">'react'</span>
import { Table } from <span class="hljs-string">'react-bootstrap'</span>

import isEmpty from <span class="hljs-string">'../util/ArrayFunc'</span>

<span class="hljs-keyword">const</span> CatchTable = props =&gt; {
    <span class="hljs-keyword">const</span> {
        catches,
        showDetailModal
    } = props

    <span class="hljs-keyword">if</span> (isEmpty(catches)) {
        <span class="hljs-keyword">return</span>(
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Table</span> <span class="hljs-attribute">responsive</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">thead</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">tr</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">th</span>&gt;</span>Catch<span class="hljs-tag">&lt;/<span class="hljs-title">th</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">th</span>&gt;</span>Type of fish<span class="hljs-tag">&lt;/<span class="hljs-title">th</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">th</span>&gt;</span>Date<span class="hljs-tag">&lt;/<span class="hljs-title">th</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">tr</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">thead</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">Table</span>&gt;</span>
        )
    }

    const table = () =&gt; {
        let rows = []

        for (let item in catches) {
            let c = catches[item]
            let date = new Date(c.dateCaught).toLocaleDateString()

            rows.push(
                <span class="hljs-tag">&lt;<span class="hljs-title">tr</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{item}</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{()</span> =&gt;</span> showDetailModal(c)}&gt;
                    <span class="hljs-tag">&lt;<span class="hljs-title">td</span>&gt;</span>{c.tripName}<span class="hljs-tag">&lt;/<span class="hljs-title">td</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">td</span>&gt;</span>{c.fishType}<span class="hljs-tag">&lt;/<span class="hljs-title">td</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">td</span>&gt;</span>{date}<span class="hljs-tag">&lt;/<span class="hljs-title">td</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">tr</span>&gt;</span>
            )
        }

        return (
            <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">Table</span> <span class="hljs-attribute">responsive</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">thead</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">tr</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-title">th</span>&gt;</span>Catch<span class="hljs-tag">&lt;/<span class="hljs-title">th</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-title">th</span>&gt;</span>Type of fish<span class="hljs-tag">&lt;/<span class="hljs-title">th</span>&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-title">th</span>&gt;</span>Date<span class="hljs-tag">&lt;/<span class="hljs-title">th</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-title">tr</span>&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-title">thead</span>&gt;</span>

                    <span class="hljs-tag">&lt;<span class="hljs-title">tbody</span>&gt;</span>
                        {rows}
                    <span class="hljs-tag">&lt;/<span class="hljs-title">tbody</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">Table</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        )
    }

    return table()
}

export default CatchTable;
</span></code></pre>
<p>The component’s props are going to be catches, which is the posted_catches state variable from the App, and showDetailModal, which is going to be the showing_detail_modal state variable. The first thing the component will do is check if there are any catches at all. If there are not, it just returns an empty table. Otherwise it calls the <code>table()</code> function</p>
<p>The <code>table</code> function dynamically builds each row, one for each catch. The columns are going to be the tripName, fishType, and dateCaught. Each row has an onClick function that allows the user to view the full details of the catch associated with the row being clicked by passing the catch to the detail modal. Notice how the onClick function is defined as an arrow function. If we define the onClick as <code>onClick={showDetailModal(c)}</code> it actually calls the function upon render, not when it’s clicked. The difference is that the arrow function gives us the function <em>itself</em>, and the other definition gives us what the function <em>returns</em>. Also don’t worry about the undeclared property warning for the properties of the Catches. IntelliJ does not know what they are, but Grails does and React will.</p>
<p>Next, we will build the catch detail modal. In <em>/webapp/components/modals/</em> make a JavaScript file called <code>CatchDetailModal</code>.</p>
<pre><code class="language-js">import React from <span class="hljs-string">'react'</span>
import { Modal, Image } from <span class="hljs-string">'react-bootstrap'</span>


<span class="hljs-keyword">const</span> CatchDetailModal = props =&gt; {
    <span class="hljs-keyword">const</span> {
        showing,
        hideModal,
        selected_catch
    } = props

    <span class="hljs-keyword">let</span> img_attached = (selected_catch.image !== <span class="hljs-literal">null</span>)

    <span class="hljs-keyword">let</span> img = img_attached ? `../images/uploaded/${selected_catch.image}` : <span class="hljs-string">''</span>

    <span class="hljs-keyword">let</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(selected_catch.dateCaught).toLocaleDateString()


    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Modal</span> <span class="hljs-attribute">show</span>=<span class="hljs-value">{showing}</span> <span class="hljs-attribute">onHide</span>=<span class="hljs-value">{hideModal}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">Modal.Header</span> <span class="hljs-attribute">closeButton</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">Modal.Title</span>&gt;</span>{selected_catch.tripName}<span class="hljs-tag">&lt;/<span class="hljs-title">Modal.Title</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">Modal.Header</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">Modal.Body</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">b</span>&gt;</span>Date: <span class="hljs-tag">&lt;/<span class="hljs-title">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>{date}<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">br</span>/&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">b</span>&gt;</span>Fish type: <span class="hljs-tag">&lt;/<span class="hljs-title">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>{selected_catch.fishType}<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">br</span>/&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">b</span>&gt;</span>Comments: <span class="hljs-tag">&lt;/<span class="hljs-title">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>{selected_catch.comment}<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">br</span>/&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">b</span>&gt;</span>Location: <span class="hljs-tag">&lt;/<span class="hljs-title">b</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">span</span>&gt;</span>{selected_catch.xCoord}, {selected_catch.yCoord}<span class="hljs-tag">&lt;/<span class="hljs-title">span</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">br</span>/&gt;</span>
                { /* only displays if there is an image */
                    img_attached &amp;&amp;
                    <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{{width:</span> <span class="hljs-attribute">250</span>, <span class="hljs-attribute">height:</span> '<span class="hljs-attribute">auto</span>'}}&gt;</span>
                        <span class="hljs-tag">&lt;<span class="hljs-title">Image</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">{img}</span> <span class="hljs-attribute">responsive</span>/&gt;</span>
                    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
                }
            <span class="hljs-tag">&lt;/<span class="hljs-title">Modal.Body</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">Modal</span>&gt;</span>
    );
}

export default CatchDetailModal;
</span></code></pre>
<p>Modals in React are fairly simple. They have two properties: <code>show</code> and <code>onHide</code>. <code>show</code> takes a boolean which is usually set with a state variable. <code>true</code> means the modal is being displayed, and <code>false</code> means it is being hidden. <code>onHide</code> is what happens when the modal is to be hidden. In most cases, it is a function that sets the show variable to false. For the catch detail modal, <code>show</code> is going to be the <code>showing_detail_modal</code> state variable, and <code>onHide</code> is going to be a function in App.js passed as a prop that hides the modal. The modal will take one more prop: the catch from the table that was clicked. The contents of the modal will be the details of the catch, with some conditional rendering to handle if the user uploaded an image. Line 14 grabs the appropriate image from the <em>/webapp/images/uploaded/</em> folder that was created earlier.</p>
<p>Finally, we will build the loading modal.</p>
<pre><code class="language-js">import React from <span class="hljs-string">'react'</span>
import { Modal } from <span class="hljs-string">'react-bootstrap'</span>

import spinner from <span class="hljs-string">'../../images/spinner.gif'</span>

<span class="hljs-keyword">const</span> LoadingModal = props =&gt; {
    <span class="hljs-keyword">const</span> {
        showing,
        hideModal,
        message
    } = props;


    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Modal</span> <span class="hljs-attribute">show</span>=<span class="hljs-value">{showing}</span> <span class="hljs-attribute">onHide</span>=<span class="hljs-value">{hideModal}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">Modal.Header</span> <span class="hljs-attribute">closeButton</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">Modal.Title</span>&gt;</span>{message}<span class="hljs-tag">&lt;/<span class="hljs-title">Modal.Title</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">Modal.Header</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">Modal.Body</span>&gt;</span>
                {spinner}
            <span class="hljs-tag">&lt;/<span class="hljs-title">Modal.Body</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">Modal</span>&gt;</span>
    )
}

export default LoadingModal
</span></code></pre>
<p>This modal will have the same props, except replacing the catch prop with a loading message. The spinner in the modal body has already been provided to us by Grails; there is no need to download one. This is also how images get imported for use in React; just treat it like any other file.</p>
<p>Finally, lets go back to App.js. Time to put it all together. Underneath the <code>componentWillUpdate()</code> function, let’s add our modal functions.</p>
<pre><code class="language-js"><span class="hljs-comment">/** opens the loading modal */</span>
showLoadingModal = m =&gt; {
    <span class="hljs-keyword">this</span>.setState({
        loading_message: m,
        showing_loading_modal: <span class="hljs-literal">true</span>
    })
}

<span class="hljs-comment">/** closes the loading modal */</span>
hideLoadingModal = () =&gt; {
    <span class="hljs-keyword">this</span>.setState({
        showing_loading_modal: <span class="hljs-literal">false</span>,
        loading_message: <span class="hljs-string">''</span>
    })
}

<span class="hljs-comment">/** opens the detail modal */</span>
showDetailModal = c =&gt; {
    <span class="hljs-keyword">this</span>.setState({
        display_catch: c,
        showing_detail_modal: <span class="hljs-literal">true</span>
    })
}

<span class="hljs-comment">/** closes the detail modal */</span>
hideDetailModal = () =&gt; {
    <span class="hljs-keyword">this</span>.setState({
        showing_detail_modal: <span class="hljs-literal">false</span>,
        display_catch: {}
    })
}
</code></pre>
<p>The show functions take a parameter to pass to their respective modals. The parameter gets set as the value of its respective state variable, and when the modals are hidden, those state variables get cleared for reuse.</p>
<p>Under these functions we will add one more function to get the catches from Grails</p>
<pre><code class="language-js"><span class="hljs-comment">/** shows catches that have been uploaded */</span>
showCatches = () =&gt; {
    <span class="hljs-keyword">this</span>.showLoadingModal(<span class="hljs-string">'RETRIEVING CATCHES...'</span>)

    <span class="hljs-keyword">const</span> url = <span class="hljs-string">"/catch/getCatches"</span>;

    fetch(url, {
        method: <span class="hljs-string">'GET'</span>,
        credentials: <span class="hljs-string">'same-origin'</span>,     <span class="hljs-comment">// Need credentials so that the JSESSIONID cookie is sent</span>
    })
    .then(r =&gt; {
        r.json()
        .then(catches =&gt; {
            <span class="hljs-keyword">if</span> (!isEmpty(catches)) {
                <span class="hljs-keyword">let</span> c = []

                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> fish <span class="hljs-keyword">in</span> catches) {
                    c.push(catches[fish])
                }

                <span class="hljs-keyword">this</span>.setState({posted_catches: c})

                <span class="hljs-keyword">this</span>.hideLoadingModal()
            }
        })
        .catch(e =&gt; <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"App.ShowCatches"</span>, e))
    })
}
</code></pre>
<p>This function is going to be making a fetch request, which means that we will have to use the loading modal to show the user that something is happening. The url this time is
<em>/catch/getCatches/</em> same as the one we manually used earlier. Since the catches in Grails get returned as JSON, we will use the <code>json()</code> function for the fetch response so that we can view the properties of the Catch. The correct way to update an array as a state variable in React is to treat it as if it was immutable. Create a new array that is either empty or the same as the state variable array, depending on what you are trying to do, and perform the operations on that. Then, set that array as the new state variable.</p>
<p>Finally, we will update the render function. Now that we have more state variables, they need to be added to the <code>const</code> block to be more easily referenced, as well as the components we just made.</p>
<pre><code class="language-js">render() {
    <span class="hljs-keyword">const</span> {
        online,
        logged_in,

        posted_catches,

        showing_detail_modal,
        display_catch,

        showing_loading_modal,
        loading_message,
    } = <span class="hljs-keyword">this</span>.state


    <span class="hljs-comment">// all items true if not empty</span>
    <span class="hljs-keyword">let</span> catches             = (!isEmpty(posted_catches))    <span class="hljs-comment">// for posted catches</span>
    <span class="hljs-keyword">let</span> catch_to_display    = (display_catch !== {})        <span class="hljs-comment">// for catch detail modal</span>
    
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">AppNav</span>
                <span class="hljs-attribute">logged_in</span>=<span class="hljs-value">{logged_in}</span>
                <span class="hljs-attribute">online</span>=<span class="hljs-value">{online}</span>
            /&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">br</span>/&gt;</span>

            { /* only show catches if online &amp; logged in */
                online &amp;&amp; logged_in &amp;&amp;
                <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{app_styles.button}</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">Button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.showCatches}</span> <span class="hljs-attribute">bsStyle</span>=<span class="hljs-value">"success"</span>&gt;</span>Show Your Catches<span class="hljs-tag">&lt;/<span class="hljs-title">Button</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">br</span>/&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
            }
            { /* only show if there have been catches posted */
                catches &amp;&amp;
                <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">CatchTable</span>
                        <span class="hljs-attribute">catches</span>=<span class="hljs-value">{posted_catches}</span>
                        <span class="hljs-attribute">showDetailModal</span>=<span class="hljs-value">{this.showDetailModal}</span>
                    /&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
            }

            {/* modals */}
            <span class="hljs-tag">&lt;<span class="hljs-title">LoadingModal</span>
                <span class="hljs-attribute">showing</span>=<span class="hljs-value">{showing_loading_modal}</span>
                <span class="hljs-attribute">hideModal</span>=<span class="hljs-value">{this.hideLoadingModal}</span>
                <span class="hljs-attribute">message</span>=<span class="hljs-value">{loading_message}</span>
            /&gt;</span>
            {
                catch_to_display &amp;&amp;
                <span class="hljs-tag">&lt;<span class="hljs-title">CatchDetailModal</span>
                    <span class="hljs-attribute">showing</span>=<span class="hljs-value">{showing_detail_modal}</span>
                    <span class="hljs-attribute">hideModal</span>=<span class="hljs-value">{this.hideDetailModal}</span>
                    <span class="hljs-attribute">selected_catch</span>=<span class="hljs-value">{display_catch}</span>
                /&gt;</span>
            }
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
    );
}
</span></code></pre>
<p>The lines at 154 and 155 are conditions for conditionally rendering the Catch table and Catch detail modal respectively. They must be conditionally rendered so that the app does not crash trying to do operations on empty or undefined objects.
The button on line 167 has the <code>showCatches</code> function we made earlier as its <code>onClick</code> function. After the function completes its run, the <code>catches</code> boolean from line 154 becomes true, which allows the Catch table to be rendered. Since the fetch requires you to be online and logged in to get a proper response, we should only allow it to be rendered if those requirements are met.
Notice the functions being passed as props to the Catch table, loading modal, and Catch detail modal. These are the functions being referenced as props inside of the components when we defined them earlier, and defined here rather than inside the components themselves.</p>
<p>Run the app again. Initially, it looks the exact same. Log in, and the <code>showCatches</code> button appears. Click on it, and the table appears with the catch that was Bootstrapped into the database</p>
<center><img src="images/9.png" alt="" height="300" width="1000"></center>
<p>Click on the row in the table, and the modal with the Catch details appears.</p>
<center><img src="images/10.png" alt="" height="400" width="600"></center>
<p>The next step is to use what we learned to create a new catch and save it to Grails. Recall that this part is supposed to work regardless of an internet connection. We will set this up now.</p>
<h3>Offline Functionality</h3>
<p>To make our app work offline, we will need something called a <a href="https://developers.google.com/web/fundamentals/primers/service-workers/">service worker</a>. A service worker is a script that runs in the background and provides functionality that does not require user interaction. Our service worker will cache our app so that it can be accessed offline.</p>
<p>In the <em>/src/webapp/</em> folder, make a JavaScript file called <code>sw</code> which will be short for ‘service worker’. Fill it out like this, remembering to change the app name at line 5 to whatever you named yours:</p>
<pre><code class="language-js"><span class="hljs-comment">/** SERVICE WORKER */</span>
self.addEventListener(<span class="hljs-string">'install'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(event)</span> </span>{
    self.skipWaiting()
    caches.open(<span class="hljs-string">'fishing_app'</span>)
        .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cache)</span> </span>{
            <span class="hljs-keyword">return</span> cache.addAll(
                [
                    <span class="hljs-string">'/'</span>,
                    <span class="hljs-string">'/assets/bundle.js?compile=false'</span>,
                    <span class="hljs-string">'/assets/favicon.ico'</span>,
                    <span class="hljs-string">'/assets/bootstrap.css?compile=false'</span>,
                    <span class="hljs-string">'/assets/bootstrap.js?compile=false'</span>,
                    <span class="hljs-string">'/assets/jquery-2.2.0.min.js?compile=false'</span>
                ]
            );
        })
        .catch(e =&gt; {<span class="hljs-built_in">console</span>.error(`error <span class="hljs-keyword">in</span> caches: ${e}`)})
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Install event:'</span>, event);
});


<span class="hljs-comment">// Cache falling back to the network</span>
<span class="hljs-comment">// https://developers.google.com/web/ilt/pwa/caching-files-with-service-worker</span>
self.addEventListener(<span class="hljs-string">'fetch'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(event)</span> </span>{
    event.respondWith(
        caches.match(event.request).then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(response)</span> </span>{
            <span class="hljs-keyword">return</span> response || fetch(event.request);
        })
    );
});
</code></pre>
<p>The files being added to the cache cover our whole app. The first file <code>/</code> is our <em>index.gsp</em> in the views folder, which our React app is rendered on top of. The next line <code>bundle.js</code> contains all of our JavaScript. The rest of the files are other assets we need, Bootstrap for styling and JQuery.</p>
<p>In App.js, go back to the <code>componentWillMount()</code> function, and add the following code to the online check to register the service worker:</p>
<pre><code class="language-js"><span class="hljs-comment">/** checks for online &amp; logged in status */</span>
componentWillMount() {
    <span class="hljs-comment">// check if online</span>
    <span class="hljs-keyword">this</span>.setState({online: navigator.onLine})


    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.state.online) {
        
        <span class="hljs-comment">// check if a service worker is supported then register it</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-string">'serviceWorker'</span> <span class="hljs-keyword">in</span> navigator) {
            navigator.serviceWorker.register(<span class="hljs-string">'./sw.js'</span>)
                .then(() =&gt; { <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Service worker registered."</span>)})
                .catch(e =&gt; <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"Service worker error:"</span>, e))
        }
        

        <span class="hljs-comment">// check if logged in</span>
        <span class="hljs-keyword">const</span> url = <span class="hljs-string">"/user/getLogin"</span>;

        fetch(url, {
            method: <span class="hljs-string">'GET'</span>,
            credentials: <span class="hljs-string">'same-origin'</span>,
        })
            .then(r =&gt; r.text())
            .then(text =&gt; {
                <span class="hljs-keyword">if</span> (text === <span class="hljs-string">'false'</span>){
                    <span class="hljs-keyword">this</span>.setState({logged_in: <span class="hljs-literal">false</span>})
                }

                <span class="hljs-keyword">else</span> {
                    <span class="hljs-keyword">this</span>.setState({logged_in: <span class="hljs-literal">true</span>})
                }
            })
    }
}
</code></pre>
<p>We can test this by running the app again. When it loads, open the developer tools in your browser. The console should display this message:</p>
<center><img src="images/11.png" alt="" height="200" width="800"></center>
<p>Furthermore, click the network tab, and check the box that says Offline to turn off the internet connection.</p>
<center><img src="images/12.png" alt="" height="200" width="800"></center>
<p>Reload the page, and now, instead of getting the connection error page, we still get to see the app. The login/logout button should have also disappeared because we are offline. The network can be turned back on now.</p>
<p>One drawback to developing with a service worker that caches your app is that it will usually prefer to load the cached version of the app over the live version. If you restart the app and see none of the changes you made, open the developer tools in the browser. Navigate to the Application tab, and click on the left side bar option for ‘Clear storage’. Click the button that says ‘Clear site data’ and perform a hard reload of the page. Another workaround is using your browser's incognito mode.</p>
<center><img src="images/13.png" alt="" height="500" width="500"></center>
<p>Now we can finally add functionality to make a new catch. This will be the rest of the app.
We will create a button that opens up a modal containing the form to fill out the new Catch information. Submission of the form will save it in a queue to be uploaded to Grails when there is a stable internet connection. This queue will be represented as a table.</p>
<p>We will need to add two more state variables to start. In the constructor in App.js, add the following to the bottom of the state declaration:</p>
<pre><code class="language-js">showing_nc_modal: <span class="hljs-literal">false</span>,        <span class="hljs-comment">// new catch modal</span>
queue: [],                      <span class="hljs-comment">// offline upload queue</span>
</code></pre>
<p>We then need to add these to the state shortcut in the render function</p>
<pre><code class="language-js"><span class="hljs-keyword">const</span> {
    online,
    logged_in,

    posted_catches,

    showing_detail_modal,
    display_catch,

    showing_loading_modal,
    loading_message,

    showing_nc_modal,
    queue
} = <span class="hljs-keyword">this</span>.state
</code></pre>
<p>Under this block, where we added the conditions for rendering the Catch table and the Catch detail modal, we need to add another condition for displaying the table for the Catch queue.</p>
<pre><code class="language-js"><span class="hljs-comment">// all items true if not empty</span>
<span class="hljs-keyword">let</span> catches             = (!isEmpty(posted_catches))    <span class="hljs-comment">// for posted catches</span>
<span class="hljs-keyword">let</span> catch_to_display    = (display_catch !== {})        <span class="hljs-comment">// for catch detail modal</span>
<span class="hljs-keyword">let</span> items_in_queue      = (!isEmpty(queue))             <span class="hljs-comment">// for upload queue</span>
</code></pre>
<p>In the <code>return</code> statement, we are now going to add some more components. Below the Navbar, but above the Show Your Catches button in the render function, we are are going to add the queue, a button to submit the queue, and finally, a button for adding a new catch. Your <code>return</code> statement should look like this:</p>
<pre><code class="language-js"><span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">AppNav</span>
            <span class="hljs-attribute">logged_in</span>=<span class="hljs-value">{logged_in}</span>
            <span class="hljs-attribute">online</span>=<span class="hljs-value">{online}</span>
        /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">br</span>/&gt;</span>

        { /* shows if there is a queue */
            items_in_queue &amp;&amp;
            <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">UploadQueue</span> <span class="hljs-attribute">queue</span>=<span class="hljs-value">{queue}</span>/&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">br</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        }
        { /* only upload if online &amp; logged in */
            items_in_queue &amp;&amp; online &amp;&amp; logged_in &amp;&amp;
            <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{app_styles.button}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">Button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.uploadQueue}</span> <span class="hljs-attribute">bsStyle</span>=<span class="hljs-value">"success"</span>&gt;</span>Submit Pending Catches<span class="hljs-tag">&lt;/<span class="hljs-title">Button</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">br</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        }
        <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{app_styles.button}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">Button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.showNewCatchModal}</span> <span class="hljs-attribute">bsStyle</span>=<span class="hljs-value">"success"</span>&gt;</span>New Catch<span class="hljs-tag">&lt;/<span class="hljs-title">Button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-title">br</span>/&gt;</span>

        { /* only show catches if online &amp; logged in */
            online &amp;&amp; logged_in &amp;&amp;
            <span class="hljs-tag">&lt;<span class="hljs-title">div</span> <span class="hljs-attribute">style</span>=<span class="hljs-value">{app_styles.button}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">Button</span> <span class="hljs-attribute">onClick</span>=<span class="hljs-value">{this.showCatches}</span> <span class="hljs-attribute">bsStyle</span>=<span class="hljs-value">"success"</span>&gt;</span>Show Your Catches<span class="hljs-tag">&lt;/<span class="hljs-title">Button</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">br</span>/&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        }
        { /* only show if there have been catches posted */
            catches &amp;&amp;
            <span class="hljs-tag">&lt;<span class="hljs-title">div</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">CatchTable</span>
                    <span class="hljs-attribute">catches</span>=<span class="hljs-value">{posted_catches}</span>
                    <span class="hljs-attribute">showDetailModal</span>=<span class="hljs-value">{this.showDetailModal}</span>
                /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
        }

        {/* modals */}
        <span class="hljs-tag">&lt;<span class="hljs-title">LoadingModal</span>
            <span class="hljs-attribute">showing</span>=<span class="hljs-value">{showing_loading_modal}</span>
            <span class="hljs-attribute">hideModal</span>=<span class="hljs-value">{this.hideLoadingModal}</span>
            <span class="hljs-attribute">message</span>=<span class="hljs-value">{loading_message}</span>
        /&gt;</span>
        {
            catch_to_display &amp;&amp;
            <span class="hljs-tag">&lt;<span class="hljs-title">CatchDetailModal</span>
                <span class="hljs-attribute">showing</span>=<span class="hljs-value">{showing_detail_modal}</span>
                <span class="hljs-attribute">hideModal</span>=<span class="hljs-value">{this.hideDetailModal}</span>
                <span class="hljs-attribute">selected_catch</span>=<span class="hljs-value">{display_catch}</span>
            /&gt;</span>
        }
        <span class="hljs-tag">&lt;<span class="hljs-title">NewCatchModal</span>
            <span class="hljs-attribute">showing</span>=<span class="hljs-value">{showing_nc_modal}</span>
            <span class="hljs-attribute">hideModal</span>=<span class="hljs-value">{this.hideNewCatchModal}</span>
            <span class="hljs-attribute">submitNewCatch</span>=<span class="hljs-value">{this.submitNewCatch}</span>
        /&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-title">div</span>&gt;</span>
);
</span></code></pre>
<p>We conditionally render the upload queue so that it only appears if it is not empty. We are also conditionally rendering the Submit button, as we can only upload Catches if they exist, there is an internet connection, and there is a user logged in to associate them with. The new catch button gets rendered no matter what, because they get saved locally before being uploaded to Grails. Finally, add a New Catch modal under the other modals.</p>
<p>Next, we will add the components. We also will be making another util file to help us with the queue. In the <em>/webapp/components/</em> folder, make another JavaScript file called <code>UploadQueue</code>. In the <em>modals</em> folder, add another file called <code>NewCatchModal</code>. Finally, in the <em>/webapp/util/</em> folder, make another Javascript file called <code>Store</code>. Don’t forget to import them in App.js!</p>
<p>We are going to start with the upload queue. It is a lot simpler than the uploaded catches, because they will be listed by <code>tripName</code> only, but it is still built the same way.</p>
<pre><code class="language-js">import React from <span class="hljs-string">'react'</span>;
import { Table } from <span class="hljs-string">'react-bootstrap'</span>;

<span class="hljs-comment">/** shows the upload queue */</span>
<span class="hljs-keyword">const</span> UploadQueue = props =&gt; {
    <span class="hljs-keyword">const</span> { queue } = props

    <span class="hljs-keyword">const</span> table = () =&gt; {
        <span class="hljs-keyword">let</span> rows = []

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> queue) {
            rows.push(
                <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">tr</span> <span class="hljs-attribute">key</span>=<span class="hljs-value">{item}</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">td</span>&gt;</span>{queue[item]}<span class="hljs-tag">&lt;/<span class="hljs-title">td</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">tr</span>&gt;</span>
            )
        }

        return (
            <span class="hljs-tag">&lt;<span class="hljs-title">Table</span> <span class="hljs-attribute">responsive</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">thead</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">tr</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">th</span>&gt;</span>Catch Queue<span class="hljs-tag">&lt;/<span class="hljs-title">th</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">tr</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">thead</span>&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-title">tbody</span>&gt;</span>
                    {rows}
                <span class="hljs-tag">&lt;/<span class="hljs-title">tbody</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">Table</span>&gt;</span>
        )
    }

    return table()
}

export default UploadQueue;
</span></code></pre>
<p>Next up is the new Catch modal.</p>
<pre><code class="language-js">import React from <span class="hljs-string">'react'</span>;
import { Modal } from <span class="hljs-string">'react-bootstrap'</span>;

import NewCatchForm from <span class="hljs-string">'../NewCatchForm'</span>


<span class="hljs-keyword">const</span> NewCatchModal = props =&gt; {
    <span class="hljs-keyword">const</span> {
        showing,
        hideModal,
        submitNewCatch
    } = props;


    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">Modal</span> <span class="hljs-attribute">show</span>=<span class="hljs-value">{showing}</span> <span class="hljs-attribute">onHide</span>=<span class="hljs-value">{hideModal}</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">Modal.Header</span> <span class="hljs-attribute">closeButton</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">Modal.Title</span>&gt;</span>New Catch<span class="hljs-tag">&lt;/<span class="hljs-title">Modal.Title</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">Modal.Header</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">Modal.Body</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">NewCatchForm</span>
                    <span class="hljs-attribute">submitNewCatch</span>=<span class="hljs-value">{submitNewCatch}</span>
                /&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">Modal.Body</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-title">Modal</span>&gt;</span>
    );
}


export default NewCatchModal;

</span></code></pre>
<p>Notice that this component is actually a combination of two components. The body of the modal contains the form the user will fill out. Notice also that the <code>submitNewCatch</code> function that it takes. In React, props can be passed down like this as far as necessary. It makes for neater code and an easier time hunting bugs. Create a new component in the components folder called <code>NewCatchForm</code>.</p>
<p>The New Catch form component is going to be a little bit different. Unlike the other components, forms cannot be stateless. They must keep an internal state to send its data somewhere else. Read <a href="https://reactjs.org/docs/forms.html">this</a> doc for more information.</p>
<p>Start by filling out the component like this:</p>
<pre><code class="language-js">import React, { Component } from <span class="hljs-string">'react'</span>;
import { Button, FormControl, FormGroup, ControlLabel, ButtonToolbar } from <span class="hljs-string">'react-bootstrap'</span>;

<span class="hljs-keyword">class</span> NewCatchForm extends Component {
    constructor() {
        super()

        <span class="hljs-keyword">this</span>.state = {
            tripName: <span class="hljs-string">''</span>,
            fishType: <span class="hljs-string">''</span>,
            dateCaught: <span class="hljs-string">''</span>,
            xCoord: <span class="hljs-number">0</span>,
            yCoord: <span class="hljs-number">0</span>,
            comment: <span class="hljs-string">''</span>,
            image: <span class="hljs-literal">null</span>,
        }
    }
</code></pre>
<p>Because it has to have a state, it needs a constructor. The state variables are simply the fields to be filled out. Under the constructor, we are going to add a cool little function that autofills the user’s coordinates based on their location. We are again going to add a <code>componentWillMount()</code> function to do this.</p>
<pre><code class="language-js"><span class="hljs-comment">/** checks location for autofilling coordinates */</span>
<span class="hljs-comment">// takes a minute</span>
componentWillMount() {
    <span class="hljs-keyword">if</span> (!navigator.geolocation)
        <span class="hljs-keyword">return</span>

    navigator.geolocation.getCurrentPosition(
        <span class="hljs-comment">// success callback</span>
        position =&gt; {
            <span class="hljs-keyword">const</span> latitude = position.coords.latitude;
            <span class="hljs-keyword">const</span> longitude = position.coords.longitude;

            <span class="hljs-keyword">if</span> (latitude == <span class="hljs-literal">null</span>
                || longitude == <span class="hljs-literal">null</span>) {
                <span class="hljs-keyword">return</span>
            }

            <span class="hljs-keyword">this</span>.setState({
                xCoord: latitude,
                yCoord: longitude
            })
        },

        <span class="hljs-comment">// failure callback</span>
        error =&gt; {
            <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"NewCatchForm - geolocate: "</span>, error)
        }
    );
}
</code></pre>
<p>While the form is being rendered, the window navigator tries to get the user’s coordinates. If it can, it sets the coordinate state variables to the these coordinates. If it cannot, it simply does nothing.</p>
<p>Next, we are going to add a function that validates the form data. If incorrect data (such as an alphabet character as one of the coordinates, or a blank tripName, fishType, or dateCaught) is sent to Grails, it will crash when it tries to save the data. To prevent this, we will perform validation at the top level. Add this under the <code>componentWillMount()</code> function.</p>
<pre><code class="language-js"><span class="hljs-comment">/** validates form */</span>
valid = () =&gt; {
    <span class="hljs-keyword">const</span> {
        tripName,
        fishType,
        dateCaught,
        xCoord,
        yCoord
    } = <span class="hljs-keyword">this</span>.state

    <span class="hljs-keyword">if</span> (tripName === <span class="hljs-string">''</span>) {
        alert(<span class="hljs-string">'Enter a trip name!'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fishType === <span class="hljs-string">''</span>) {
        alert(<span class="hljs-string">'Enter a type of fish!'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (dateCaught === <span class="hljs-string">''</span>) {
        alert(<span class="hljs-string">'Enter a date!'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((xCoord !== <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">isNaN</span>(xCoord))
        || (yCoord !== <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">isNaN</span>(yCoord))) {
        alert(<span class="hljs-string">'Coordinates must be numbers!'</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
    }

    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
</code></pre>
<p>Upon submission, this function gets called. If it returns false the form is not submitted. Under this function, we will add the submit function.</p>
<pre><code class="language-js"><span class="hljs-comment">/** submits the form if valid */</span>
handleSubmit = (e) =&gt; {
    e.preventDefault();

    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.valid())
        <span class="hljs-keyword">return</span>

    <span class="hljs-keyword">const</span> data = {
        tripName: <span class="hljs-keyword">this</span>.state.tripName,
        fishType: <span class="hljs-keyword">this</span>.state.fishType,
        dateCaught: <span class="hljs-keyword">this</span>.state.dateCaught,
        xCoord: <span class="hljs-keyword">this</span>.state.xCoord,
        yCoord: <span class="hljs-keyword">this</span>.state.yCoord,
        comment: <span class="hljs-keyword">this</span>.state.comment,
        image: <span class="hljs-keyword">this</span>.state.image
    }

    <span class="hljs-keyword">this</span>.props.submitNewCatch(data)
}
</code></pre>
<p>The parameter <code>e</code> stands for event. Upon submission of a form, an event is fired. The first thing we need to do is call <code>preventDefault()</code> on the event. This is required, because the default action tends to be something else. Next, it checks that the form is valid. If it is, it compiles the form data into an object to pass to the <code>submitNewCatch</code> function that was passed to it.</p>
<p>In React, form fields have a function property called <code>onChange</code> which fires whenever the field is changed. We need to write a change handler to store the form data in its respective state variable. Under the <code>handleSubmit</code> function, add these two functions.</p>
<pre><code class="language-js"> <span class="hljs-comment">/** form update handlers */</span>
handleChange = (e) =&gt; {
    <span class="hljs-keyword">const</span> target = e.target;
    <span class="hljs-keyword">const</span> name = target.name;
    <span class="hljs-keyword">const</span> value = target.value;

    <span class="hljs-keyword">this</span>.setState({
        [name]: value
    })
}

handleImg = (e) =&gt; {
    <span class="hljs-keyword">const</span> target = e.target;
    <span class="hljs-keyword">const</span> file = target.files[<span class="hljs-number">0</span>]

    <span class="hljs-keyword">this</span>.setState({
        image: file
    })
}
<span class="hljs-comment">/* end update handlers */</span>
</code></pre>
<p>Again, they take an event as a parameter. The target property is the field being changed. The name of the target corresponds to the name property of the field, and the value is what was typed into the field. The <code>[name]</code> syntax puts the literal value in its place, rather than a string, so that we do not have to manually check which field is being updated. The <code>handleImg</code> function is similar, and is how we handle an image upload.</p>
<p>Finally, we can build the form and the rest of the component.</p>
<pre><code class="language-js">render() {
        <span class="hljs-keyword">return</span>(
            <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">form</span> <span class="hljs-attribute">onSubmit</span>=<span class="hljs-value">{this.handleSubmit}</span>&gt;</span>
                <span class="hljs-tag">&lt;<span class="hljs-title">FormGroup</span> <span class="hljs-attribute">controlId</span>=<span class="hljs-value">"formControlsTripName"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">ControlLabel</span>&gt;</span>Trip Name<span class="hljs-tag">&lt;/<span class="hljs-title">ControlLabel</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">FormControl</span>
                        <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span>
                        <span class="hljs-attribute">placeholder</span>=<span class="hljs-value">"The name of your trip..."</span>
                        <span class="hljs-attribute">name</span>=<span class="hljs-value">"tripName"</span>
                        <span class="hljs-attribute">onChange</span>=<span class="hljs-value">{this.handleChange}</span>
                    /&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">FormGroup</span>&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-title">FormGroup</span> <span class="hljs-attribute">controlId</span>=<span class="hljs-value">"formControlsFishType"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">ControlLabel</span>&gt;</span>Fish Type<span class="hljs-tag">&lt;/<span class="hljs-title">ControlLabel</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">FormControl</span>
                        <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span>
                        <span class="hljs-attribute">placeholder</span>=<span class="hljs-value">"The type of fish you caught..."</span>
                        <span class="hljs-attribute">name</span>=<span class="hljs-value">"fishType"</span>
                        <span class="hljs-attribute">onChange</span>=<span class="hljs-value">{this.handleChange}</span>
                    /&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">FormGroup</span>&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-title">FormGroup</span> <span class="hljs-attribute">controlId</span>=<span class="hljs-value">"formControlsDateCaught"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">ControlLabel</span>&gt;</span>Date Caught<span class="hljs-tag">&lt;/<span class="hljs-title">ControlLabel</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">FormControl</span>
                        <span class="hljs-attribute">type</span>=<span class="hljs-value">"date"</span>
                        <span class="hljs-attribute">placeholder</span>=<span class="hljs-value">"The type of fish you caught..."</span>
                        <span class="hljs-attribute">name</span>=<span class="hljs-value">"dateCaught"</span>
                        <span class="hljs-attribute">onChange</span>=<span class="hljs-value">{this.handleChange}</span>
                    /&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">FormGroup</span>&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-title">FormGroup</span> <span class="hljs-attribute">controlId</span>=<span class="hljs-value">"formControlsXCoord"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">ControlLabel</span>&gt;</span>X-Coordinate<span class="hljs-tag">&lt;/<span class="hljs-title">ControlLabel</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">FormControl</span>
                        <span class="hljs-attribute">type</span>=<span class="hljs-value">"num"</span>
                        <span class="hljs-attribute">value</span>=<span class="hljs-value">{this.state.xCoord}</span>
                        <span class="hljs-attribute">name</span>=<span class="hljs-value">"xCoord"</span>
                        <span class="hljs-attribute">onChange</span>=<span class="hljs-value">{this.handleChange}</span>
                    /&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">FormGroup</span>&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-title">FormGroup</span> <span class="hljs-attribute">controlId</span>=<span class="hljs-value">"formControlsYCoord"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">ControlLabel</span>&gt;</span>Y-Coordinate<span class="hljs-tag">&lt;/<span class="hljs-title">ControlLabel</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">FormControl</span>
                        <span class="hljs-attribute">type</span>=<span class="hljs-value">"num"</span>
                        <span class="hljs-attribute">value</span>=<span class="hljs-value">{this.state.yCoord}</span>
                        <span class="hljs-attribute">name</span>=<span class="hljs-value">"yCoord"</span>
                        <span class="hljs-attribute">onChange</span>=<span class="hljs-value">{this.handleChange}</span>
                    /&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">FormGroup</span>&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-title">FormGroup</span> <span class="hljs-attribute">controlId</span>=<span class="hljs-value">"formControlsComment"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">ControlLabel</span>&gt;</span>Comment<span class="hljs-tag">&lt;/<span class="hljs-title">ControlLabel</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">FormControl</span>
                        <span class="hljs-attribute">type</span>=<span class="hljs-value">"text"</span>
                        <span class="hljs-attribute">placeholder</span>=<span class="hljs-value">"Anything you would like to mention?"</span>
                        <span class="hljs-attribute">name</span>=<span class="hljs-value">"comment"</span>
                        <span class="hljs-attribute">onChange</span>=<span class="hljs-value">{this.handleChange}</span>
                    /&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">FormGroup</span>&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-title">FormGroup</span> <span class="hljs-attribute">controlId</span>=<span class="hljs-value">"formControlsImage"</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">ControlLabel</span>&gt;</span>Upload Image<span class="hljs-tag">&lt;/<span class="hljs-title">ControlLabel</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">FormControl</span>
                        <span class="hljs-attribute">type</span>=<span class="hljs-value">"file"</span>
                        <span class="hljs-attribute">accept</span>=<span class="hljs-value">"image/*"</span>
                        <span class="hljs-attribute">name</span>=<span class="hljs-value">"image"</span>
                        <span class="hljs-attribute">onChange</span>=<span class="hljs-value">{this.handleImg}</span>
                        <span class="hljs-attribute">capture</span>
                    /&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">FormGroup</span>&gt;</span>

                <span class="hljs-tag">&lt;<span class="hljs-title">ButtonToolbar</span>&gt;</span>
                    <span class="hljs-tag">&lt;<span class="hljs-title">Button</span> <span class="hljs-attribute">id</span>=<span class="hljs-value">"submit-btn"</span> <span class="hljs-attribute">bsStyle</span>=<span class="hljs-value">"success"</span> <span class="hljs-attribute">type</span>=<span class="hljs-value">"submit"</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-title">Button</span>&gt;</span>
                <span class="hljs-tag">&lt;/<span class="hljs-title">ButtonToolbar</span>&gt;</span>
            <span class="hljs-tag">&lt;/<span class="hljs-title">form</span>&gt;</span>
        );
    }
}

export default NewCatchForm;
</span></code></pre>
<p>Now, we can build the Store util file, and put it all together. In the Store file, start by importing localforage and fetch.</p>
<pre><code class="language-js">import localforage from <span class="hljs-string">'localforage'</span>;
import <span class="hljs-string">'whatwg-fetch'</span>;
</code></pre>
<p>The first function we are going to write will store our submitted catch in localforage. We also are going to learn more about how to write Promises.</p>
<pre><code class="language-js"><span class="hljs-comment">/** function called in app to store catch data in localforage */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">storeCatch</span><span class="hljs-params">(data)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise((resolve, reject) =&gt; {
        localforage.setDriver(localforage.INDEXEDDB)
            .then(() =&gt; {
                <span class="hljs-comment">// checks if an image was uploaded</span>
                <span class="hljs-keyword">if</span> (data.image !== <span class="hljs-literal">null</span>) {
                    <span class="hljs-keyword">const</span> imageUpload = data.image

                    <span class="hljs-comment">// for converting image to blob string setup</span>
                    <span class="hljs-keyword">let</span> reader = <span class="hljs-keyword">new</span> FileReader();
                    reader.readAsDataURL(imageUpload);

                    <span class="hljs-keyword">const</span> photoID = generateGUID(); <span class="hljs-comment">// generate id for the photo</span>
                    data.image = photoID;           <span class="hljs-comment">// put it in the dictionary</span>

                    <span class="hljs-comment">// store actual image in localForage</span>
                    reader.onloadend = () =&gt; {
                        localforage.setItem(photoID, reader.result)    <span class="hljs-comment">// reader.result is the blob string</span>
                            .then(() =&gt; { <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'localstorage - photo saved!'</span>) })
                            .catch(e =&gt; reject(e))
                    };
                }

                <span class="hljs-comment">// storing the catch data in localforage in a queue</span>
                <span class="hljs-keyword">let</span> catches = []

                <span class="hljs-comment">// get the key first</span>
                localforage.getItem(<span class="hljs-string">'catches'</span>)
                    .then(q =&gt; { <span class="hljs-comment">// queue</span>

                        <span class="hljs-comment">// if there is anything in 'catches' we will push to it</span>
                        <span class="hljs-keyword">if</span> (q !== <span class="hljs-literal">null</span>) {
                            catches = q;
                        }

                        catches.push(data);

                        <span class="hljs-comment">// clear localforage catches</span>
                        localforage.setItem(<span class="hljs-string">'catches'</span>, catches)
                            .then(r =&gt; resolve(r[r.length - <span class="hljs-number">1</span>].tripName)) <span class="hljs-comment">// returns catch that was just stored</span>
                            .catch(e =&gt; reject(e))
                    })
                    .catch(e =&gt; reject(e))
            })
    });
}
</code></pre>
<p>To write a Promise, we start by returning a new Promise. As previously mentioned, it has two callback functions, <code>resolve</code> and <code>reject</code>. They are both treated like <code>return</code> statements. If the operation inside the Promise is successful, <code>resolve</code> is called, and anything that is passed to it is accessible from the caller’s <code>.then</code> call. The same is true for <code>reject</code> and the caller’s <code>.catch</code> call.</p>
<p>Localforage’s full docs can be found <a href="https://localforage.github.io/localForage/">here</a>. To use localforage, the first thing we must do is set a driver for its datastore. We will be using <a href="https://developers.google.com/web/ilt/pwa/working-with-indexeddb">IndexedDB</a>. All the localforage operations must be done inside the resolved Promise.</p>
<p>To store the Catches, we first will generate a unique id for the image, if there is one attached. The id replaces the image in the Catch, and the Catch is stored in a queue in localforage. The image itself is converted to a blob string stored in another queue and its key is its id.</p>
<p>The first thing we do is check the Catch data for an image. If there is one, we generate a unique id using the following helper functions:</p>
<pre><code class="language-js"><span class="hljs-comment">// Use with generateGUID function to make random int</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genString</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> (((<span class="hljs-number">1</span>+<span class="hljs-built_in">Math</span>.random())*<span class="hljs-number">0x10000</span>)|<span class="hljs-number">0</span>).toString(<span class="hljs-number">16</span>).substring(<span class="hljs-number">1</span>);
}

<span class="hljs-comment">// For generating unique ID</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generateGUID</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> (
        genString()
        + genString()
        + <span class="hljs-string">"-"</span>
        + genString()
        + <span class="hljs-string">"-4"</span>
        + genString().substr(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)
        + <span class="hljs-string">"-"</span>
        + genString()
        + <span class="hljs-string">"-"</span>
        + genString()
        + genString()
        + genString()
    ).toLowerCase();
}
</code></pre>
<p>Then, we store the image in localforage. Next, we check localforage for the queue we will call <code>‘catches’</code>. If it exists, we add the Catch to it and put the queue back in localforage. If not, we make a new queue. After the catch is stored, we resolve the Promise, returning the tripName of the catch we just saved. The caller, which is App.js, will take this and add it to its queue state variable so the user can see it in the table. If there are any errors, we reject the Promise, passing the error back up.</p>
<p>Next, we need to write a function to submit the queue to Grails.</p>
<pre><code class="language-js"><span class="hljs-comment">/**
 * function called in app to retrieve catch data from localforage
 *  &amp; post it to grails
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">submitQueue</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise((resolve, reject) =&gt; {
        localforage.setDriver(localforage.INDEXEDDB).then(() =&gt; {
            localforage.getItem(<span class="hljs-string">'catches'</span>)
                .then(q =&gt; {

                    <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>)
                        <span class="hljs-keyword">return</span>

                    <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>

                    <span class="hljs-keyword">for</span> (i; i &lt; q.length; i++) {
                        <span class="hljs-keyword">if</span> (q[i] == <span class="hljs-literal">null</span>)
                            <span class="hljs-keyword">continue</span>

                        submitHelper(q[i])
                    }

                    <span class="hljs-comment">// after all items in the queue are submitted, remove them</span>
                    localforage.removeItem(<span class="hljs-string">'catches'</span>)
                        .then(() =&gt; { resolve(<span class="hljs-string">'Your catches have been uploaded successfully!'</span>) })
                        .catch(e =&gt; { reject(e) })
                })
                .catch(e =&gt; { reject(e) })
        });
    })
}
</code></pre>
<p>We will write another Promise to achieve this. Again, we must set the driver for localforage before we can use it. This time, we get the queue from localforage. Then, one at a time to avoid race conditions, we pass each item to a helper function that uploads it to Grails. Finally, we remove the queue from localforage, because it is no longer needed. We resolve this Promise with a success message. Here is the helper function:</p>
<pre><code class="language-js"><span class="hljs-comment">/** submits one at a time */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">submitHelper</span><span class="hljs-params">(item)</span> </span>{
    <span class="hljs-keyword">const</span> url = <span class="hljs-string">"/catch/newCatch"</span>;
    <span class="hljs-keyword">let</span> formDat = <span class="hljs-keyword">new</span> FormData();

    <span class="hljs-comment">// if there is a photo</span>
    <span class="hljs-keyword">if</span> (item.image !== <span class="hljs-literal">null</span>) {
        <span class="hljs-comment">// This is getting the photo of the catch out of localforage</span>
        <span class="hljs-comment">// it then makes a promise in which the fetch is called after</span>
        <span class="hljs-comment">// it is full filled</span>
        localforage.getItem(item.image,
            (err, data) =&gt; {
                <span class="hljs-comment">// convert the blob string back to an appropriate file</span>
                <span class="hljs-keyword">let</span> block = data.split(<span class="hljs-string">";"</span>);
                <span class="hljs-keyword">let</span> contentType = block[<span class="hljs-number">0</span>].split(<span class="hljs-string">":"</span>)[<span class="hljs-number">1</span>];
                <span class="hljs-keyword">let</span> realData = block[<span class="hljs-number">1</span>].split(<span class="hljs-string">","</span>)[<span class="hljs-number">1</span>];
                <span class="hljs-keyword">let</span> image = b64toBlob(realData, contentType);


                item.image = image

                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> item) {
                    <span class="hljs-keyword">if</span> (item.hasOwnProperty(key)) {
                        formDat.append(key, item[key])
                    }
                }

            })
            .then(() =&gt; {
                fetch(url, {
                    method: <span class="hljs-string">'POST'</span>,
                    credentials: <span class="hljs-string">'same-origin'</span>,
                    body: formDat
                })
                    .then(r =&gt;  {
                        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Store.submit"</span>, r.status)
                    })

                localforage.removeItem(item.image);
            });
    }
    <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> item) {
            <span class="hljs-keyword">if</span> (item.hasOwnProperty(key)) {
                formDat.append(key, item[key])
            }
        }

        fetch(url, {
            method: <span class="hljs-string">'POST'</span>,
            credentials: <span class="hljs-string">'same-origin'</span>,
            body: formDat
        })
            .then(r =&gt;  {
                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Store.submit"</span>, r.status)
            })
    }
}
</code></pre>
<p>The function checks the item for an image. If there is, it grabs it out of localforage, converts it back into its file, and attaches it to the Catch. It then posts the Catch to the <code>newCatch</code> function in the Catch controller in Grails. Finally, it removes the image from localforage. If there is no image attached, it simply posts the Catch data to Grails. Here is the <code>b64toBlob</code> function that converts the image from the string to the file.</p>
<pre><code class="language-js"><span class="hljs-comment">// Converts blob string to a blob file</span>
<span class="hljs-comment">// Taken from https://ourcodeworld.com/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b64toBlob</span><span class="hljs-params">(b64Data, contentType, sliceSize)</span> </span>{
    contentType = contentType || <span class="hljs-string">''</span>;
    sliceSize = sliceSize || <span class="hljs-number">512</span>;

    <span class="hljs-keyword">var</span> byteCharacters = atob(b64Data);
    <span class="hljs-keyword">var</span> byteArrays = [];

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> offset = <span class="hljs-number">0</span>; offset &lt; byteCharacters.length; offset += sliceSize) {
        <span class="hljs-keyword">var</span> slice = byteCharacters.slice(offset, offset + sliceSize);

        <span class="hljs-keyword">var</span> byteNumbers = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(slice.length);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; slice.length; i++) {
            byteNumbers[i] = slice.charCodeAt(i);
        }

        <span class="hljs-keyword">var</span> byteArray = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Uint8Array</span>(byteNumbers);

        byteArrays.push(byteArray);
    }

    <span class="hljs-keyword">var</span> blob = <span class="hljs-keyword">new</span> Blob(byteArrays, {type: contentType});
    <span class="hljs-keyword">return</span> blob;
}
</code></pre>
<p>Finally, we will write a Promise to get the queue from localforage and return it as an array of tripNames. This is going to be called when the app loads so that the user can close and open the app and still see all the Catches they made. We then will need to export the three Promises to use in App.js</p>
<pre><code class="language-js"><span class="hljs-comment">/** gets current queue from localforage */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getQueue</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise((resolve, reject) =&gt; {
        localforage.setDriver(localforage.INDEXEDDB)
            .then(() =&gt; {
                localforage.getItem(<span class="hljs-string">'catches'</span>)
                    .then(q =&gt; { <span class="hljs-comment">// queue</span>
                        <span class="hljs-keyword">let</span> list = []

                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> item <span class="hljs-keyword">in</span> q)
                            list.push(q[item].tripName)


                        resolve(list)
                    })
                    .catch(e =&gt; { reject(e) })
            });
    })
}

export <span class="hljs-keyword">default</span> { storeCatch, getQueue, submitQueue }
</code></pre>
<p>Putting it all together, we will add the functions being called by the components. Under the rest of the show/hide modal functions, add a show and a hide function for the new Catch modal.</p>
<pre><code class="language-js"> <span class="hljs-comment">/** opens the new catch modal */</span>
showNewCatchModal = () =&gt; {
    <span class="hljs-keyword">this</span>.setState({
        showing_nc_modal: <span class="hljs-literal">true</span>
    })
}

<span class="hljs-comment">/** closes the new catch modal */</span>
hideNewCatchModal = () =&gt; {
    <span class="hljs-keyword">this</span>.setState({
        showing_nc_modal: <span class="hljs-literal">false</span>
    })
}
</code></pre>
<p>Next, the function to submit a new Catch from the form.</p>
<pre><code class="language-js"><span class="hljs-comment">/** stores the catch data in localforage */</span>
submitNewCatch = data =&gt; {
    <span class="hljs-keyword">this</span>.showLoadingModal(<span class="hljs-string">'STORING CATCH IN QUEUE...'</span>)

    Store.storeCatch(data)
        .then(d =&gt; {
            <span class="hljs-keyword">let</span> cache = <span class="hljs-keyword">this</span>.state.queue

            cache.push(d)

            <span class="hljs-keyword">this</span>.setState({queue: cache})
        })
        .catch(e =&gt; {<span class="hljs-built_in">console</span>.error(<span class="hljs-string">"App.submitNewCatch"</span>, e)})

    <span class="hljs-keyword">this</span>.hideLoadingModal()

    <span class="hljs-keyword">this</span>.hideNewCatchModal()
}
</code></pre>
<p>The function calls our Promise, and pushes the catch that was stored into the app’s queue.</p>
<p>Finally, we will write the function that uploads the queue.</p>
<pre><code class="language-js"> <span class="hljs-comment">/** uploads the queue */</span>
uploadQueue = () =&gt; {
    <span class="hljs-keyword">this</span>.showLoadingModal(<span class="hljs-string">'UPLOADING CATCH QUEUE...'</span>)

    Store.submitQueue()
        .then(m =&gt; {
            <span class="hljs-keyword">this</span>.setState({queue: []})

            alert(m)
        })
        .catch(e =&gt; {
            <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"App.uploadQueue"</span>, e)
        })

    <span class="hljs-keyword">this</span>.hideLoadingModal()
}
</code></pre>
<p>The <code>submitQueue</code> promise resolves with a message, which gets passed to an alert.</p>
<p>One last thing before we’re done: we need to retrieve the queue when the app loads. Go back up to the <code>componentWillMount()</code> function and add this to the bottom:</p>
<pre><code class="language-js"><span class="hljs-keyword">this</span>.showLoadingModal(<span class="hljs-string">'LOADING UPLOAD QUEUE...'</span>)

<span class="hljs-comment">// get upload queue</span>
Store.getQueue()
    .then(q =&gt; {
        <span class="hljs-keyword">this</span>.setState({queue: []})

        <span class="hljs-keyword">if</span> (isEmpty(q)) {
            <span class="hljs-keyword">return</span>
        }

        <span class="hljs-keyword">this</span>.setState({queue: q})
    })
    .catch(e =&gt; {
        <span class="hljs-built_in">console</span>.error(<span class="hljs-string">"App.cwm.Store.getQueuePromise"</span>, e)
    })

<span class="hljs-keyword">this</span>.hideLoadingModal()
</code></pre>
<p>If there is a queue in localstorage, it gets put in the state to be added to the table.</p>
<p>Now, re-run the app. There should now be a New Catch button. Remember to flush the cache as mentioned earlier if there appear to be no changes.</p>
<center><img src="images/14.png" alt="" height="100" width="700"></center>
<p>Click on it, and our form appears.</p>
<center><img src="images/15.png" alt="" height="500" width="500"></center>
<p>Fill out the form, submit it, and the Catch queue appears. Logging in makes the queue submission button appear.</p>
<center><img src="images/16.png" alt="" height="200" width="700"></center>
<p>After submitting the queue, we must click the Show Your Catches button again to view all the catches that were posted.</p>
<center><img src="images/17.png" alt="" height="200" width="800"></center>
<p>Each catch in the table can be clicked to view its details.</p>
<center><img src="images/18.png" alt="" height="400" width="500"></center>
<p>That’s it! The app is complete. Hopefully this tutorial takes some of the confusion out of writing apps in React, as well as writing progressive web apps in general.</p>
